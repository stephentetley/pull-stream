/*
 * Copyright 2020 Stephen Tetley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




///
/// The Stream type.
///
/// A stream provides "demand driven" access to its elements - successive
/// elements are only produced when needed. Internally the stream is
/// represented as a "pull stream" plus a finalizer.
///
/// Note - a stream is not "replayable".
///
pub opaque type StateMPullStream[st, a] = 
    { generate: Unit ~> (Unit ~> StateM[st, StateMPullStream/Internal.Step[a]])
    , finalize: Unit ~> StateM[st, Unit]
    }

namespace StateMPullStream/Internal {

    ///
    /// The internal type of stream answers.
    /// `Skip` allows us to write `filter` and other functions that do not
    /// necessarily produce a value at each step.
    ///
    pub enum Step[a] {
        case Done,
        case Skip,
        case Yield(a)
    }

}

namespace StateMPullStream {

    use StateMPullStream/Internal.Step;
    use StateMPullStream/Internal.Step.{Done, Skip, Yield};

    ///
    /// Returns the empty stream.
    ///
    pub def empty(): StateMPullStream[st, a] =
        use StateMonad.{return};
        let gen = () -> {
            let dummy = ref 0;
            let next = () -> {
                dummy := 1;
                return(Done)
            };
            next
        };
        StateMPullStream({generate = gen, finalize = _ -> return() as & Impure})

    ///
    /// Helper function to extract finalizer.
    ///
    def getFinalizer(s: StateMPullStream[st, a]): Unit ~> StateM[st, Unit] =
        let StateMPullStream(body) = s;
        body.finalize

    ///
    /// Helper function to extract generator.
    ///
    def getGenerator(s: StateMPullStream[st, a]): Unit ~> (Unit ~> StateM[st, Step[a]]) =
        let StateMPullStream(body) = s;
        body.generate

    ///
    /// Truncate a stream but keep its finalizer.
    ///
    def _emptyOf(s: StateMPullStream[st, a]): StateMPullStream[st, a] =
        use StateMonad.{return};
        let gen = () -> {
            let dummy = ref 0;
            let next = () -> {
                dummy := 1;
                return(Done)
            };
            next
        };
        StateMPullStream({generate = gen, finalize = getFinalizer(s)})

    ///
    /// Construct an Iterator.
    ///
    /// The Iterator must provide three functions.
    ///
    /// * `hasNext` to test whether the iterator can still produce more values.
    ///
    /// * `next` to produce another value iff `hasNext` has indicated more values are available.
    ///
    /// * `finalize` to be called when the iterator has exhausted all its input. `finalize` should close
    ///    any open resources.
    ///
    type alias StateMIterator[st, a] = { hasNext: Unit -> StateM[st, Bool], next: Unit -> StateM[st, a], finalize: Unit -> StateM[st, Unit] }

    ///
    /// Returns a stream generated by an Iterator.
    ///
    pub def fromIterator(iterator: StateMIterator[st, a]): StateMPullStream[st, a] =
        use StateMonad.{return, bind, map};
        let iterHasNext = iterator.hasNext;
        let iterNext = iterator.next;
        let iterFinal = iterator.finalize;
        let gen = () -> {
            let dummy = ref 0;
            let next = () -> {
                dummy := 1;
                bind( iterHasNext()
                    , more -> 
                        if (not more)
                            return(Done)
                        else 
                            map(x -> Yield(x), iterNext())
                )
            };
            next
        };
        StateMPullStream({generate = gen, finalize = _ -> iterFinal() as & Impure}) 

    ///
    /// Returns the stream `s` as a list.
    ///
    pub def toList(s: StateMPullStream[st, a]): StateM[st, List[a]] =
        use StateMonad.{flatMap, return, liftAction};
        let generate1   = getGenerator(s);
        let finalize1   = getFinalizer(s);
        let* sf         = liftAction(_ -> generate1());
        let* ans        = toListHelper(sf, Nil : List[a]);
        let* outer      = liftAction(_ -> finalize1());
        let* ()         = outer;    /// actually run finalizer
        return(ans)

    ///
    /// Helper function for `toList`.
    ///
    /// Precodition: b < e
    ///
    def toListHelper(sf : Unit ~> StateM[st, Step[a]], ac: List[a]) : StateM[st, List[a]] =
        use StateMonad.{flatMap, return, liftAction};
        let* outer = liftAction(_ -> sf());
        let* ans = outer;
        match ans {
            case Done     => return(List.reverse(ac))
            case Skip     => toListHelper(sf, ac)
            case Yield(a) => toListHelper(sf, a :: ac)
        }


}